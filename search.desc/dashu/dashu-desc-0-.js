searchState.loadedDescShard("dashu", 0, "The meta crate that re-exports all <code>dashu</code> numeric types.\nA verbose alias for DBig (base 10, rounding to the nearest)\nA verbose alias for IBig\nA verbose alias for UBig\nA verbose alias for RBig\nA verbose alias for FBig (base 2, rounding towards zero)\nDefintions of common traits\nCreate an arbitrary precision float number (…\nCreate an arbitrary precision float number (…\nArbitrary precision floating point number\nCreate an arbitrary precision signed integer (…\nArbitrary precision integer number\nArbitrary precision rational number\nCreate an arbitrary precision rational number (…\nCreate an arbitrary precision float number (…\nCreate an arbitrary precision float number (…\nCreate an arbitrary precision signed integer (…\nCreate an arbitrary precision rational number (…\nCreate an arbitrary precision unsigned integer (…\nCreate an arbitrary precision unsigned integer (…\nAbsolute value.\nCheck whether the magnitude of this number is equal the …\nCompare the magnitude of this number to the magnitude of …\nRepresent an calculation result with a possible error.\nBit query for integers\nNumber out of bounds.\nCompute the cubic root of the number.\nComputer the floored cubic root of the number and return …\nCompute Euclidean quotient.\nCompute quotient and remainder at the same time.\nCompute quotient inplace and return remainder at the same …\nCompute Euclidean quotient and remainder at the same time.\nFast estimation of the binary logarithm of a number\nThe result is exact, contains the result value\nCompute the greatest common divisor between self and the …\nSupport encoding and decoding of floats into (mantissa, …\nCompute the greatest common divisor.\nThe radices of different components of the number are …\nThe result is inexact, contains the result value and error\nInvalid digit for a given radix.\nCompute the multiplicative inverse (aka. reciprocal) of …\nThe conversion will cause a loss of precision\nNo digits in the string.\nThe number is not in the representation range\nError parsing a number.\nFunctions related to the power of two.\nCompute Euclidean remainder.\nAn enum representing the sign of a number\nThis trait marks the number is signed.\nCompute the square root of the number.\nComputer the floored square root of the number and return …\nUnsigned absolute value.\nThe radix is not supported.\nTrait definitions for approximated values\nTrait definitions for bitwise operations.\nReturns true if the <code>n</code>-th bit is set in its two’s …\nEffective bit length of the binary representation.\nConvert a float number <code>mantissa * 2^exponent</code> into …\nConvert <code>(mantissa, exponent)</code> to <code>mantissa * 2^exponent</code> …\nError types.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCompute the greatest common divisor between the two …\nCalculate the greatest common divisor between the two …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTest if self is a power of two (<code>2^k</code>)\nEstimate the bounds of the binary logarithm.\nEstimate the value of the binary logarithm. It’s …\nTrait definitions for math operations\nGet the smallest power of two greater than or equal to …\nTrait definitions for operations related to rings …\nTrait definitions for sign related operations.\nSome useful utility functions that are also used …\nGet the value of the calculation regardless of error\nGet a reference to the calculation result\nRepresent an calculation result with a possible error.\nThe result is exact, contains the result value\nThe result is inexact, contains the result value and error\nBit query for integers\nSupport encoding and decoding of floats into (mantissa, …\nFunctions related to the power of two.\nReturns true if the <code>n</code>-th bit is set in its two’s …\nEffective bit length of the binary representation.\nConvert a float number <code>mantissa * 2^exponent</code> into …\nConvert <code>(mantissa, exponent)</code> to <code>mantissa * 2^exponent</code> …\nTest if self is a power of two (<code>2^k</code>)\nGet the smallest power of two greater than or equal to …\nNumber out of bounds.\nThe radices of different components of the number are …\nInvalid digit for a given radix.\nThe conversion will cause a loss of precision\nNo digits in the string.\nThe number is not in the representation range\nError parsing a number.\nThe radix is not supported.\nCompute the cubic root of the number.\nFast estimation of the binary logarithm of a number\nCompute the multiplicative inverse (aka. reciprocal) of …\nCompute the square root of the number.\nEstimate the bounds of the binary logarithm.\nEstimate the value of the binary logarithm. It’s …\nComputer the floored cubic root of the number and return …\nCompute Euclidean quotient.\nCompute quotient and remainder at the same time.\nCompute quotient inplace and return remainder at the same …\nCompute Euclidean quotient and remainder at the same time.\nCompute the greatest common divisor between self and the …\nCompute the greatest common divisor.\nCompute Euclidean remainder.\nComputer the floored square root of the number and return …\nCompute the greatest common divisor between the two …\nCalculate the greatest common divisor between the two …\nAbsolute value.\nCheck whether the magnitude of this number is equal the …\nCompare the magnitude of this number to the magnitude of …\nAn enum representing the sign of a number\nThis trait marks the number is signed.\nUnsigned absolute value.\nImplementation of the nightly f32::next_down()\nImplementation of the nightly f32::next_up()\nThe base of the representation. It’s exposed as an IBig …\nThe context containing runtime information for the …\nMulti-precision float number with decimal exponent and …\nAn arbitrary precision floating point number with …\nFBig instance representing the positive infinity (+∞)\nFBig instance representing the negative infinity (-∞)\nFBig with value -1 and unlimited precision\nFBig with value 1 and unlimited precision\nUnderlying representation of an arbitrary precision …\nThe primitive integer type used to construct the big …\nFBig with value 0 and unlimited precision\nAdd two floating point numbers under this context.\nReturns the smallest integer greater than or equal to self.\nGet the context associated with the float number\nConvert an IBig instance to a FBig instance with precision …\nCompute the cubic of this number (<code>self * self * self</code>)\nCalculate the cubic of the floating point number under …\nDefault value: 0.\nGet the number of the significant digits in the float …\nGet the number of digits (under base <code>B</code>) in the significand.\nFast under-estimation of digits\nFast over-estimation of digits\nDivide two floating point numbers under this context.\nCalculate the exponential function (<code>eˣ</code>) on the floating …\nCalculate the exponential function (<code>eˣ</code>) on the floating …\nCalculate the exponential minus one function (<code>eˣ-1</code>) on …\nCalculate the exponential minus one function (<code>eˣ-1</code>) on …\nGet the exponent of the representation\nReturns the largest integer less than or equal to self.\nGet the fractional part of the float\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert raw parts (significand, exponent) into a float …\nConvert raw parts (significand, exponent) into a float …\nCreate a FBig instance from Repr and Context.\nCreate a FBig instance from Repr. Due to the limitation of …\nConvert a string in the native base (i.e. radix <code>B</code>) to FBig.\nConvert a string in the native base (i.e. radix <code>B</code>) to Repr.\nCreate a Repr instance representing the (positive) infinity\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the float number into raw <code>(signficand, exponent)</code> …\nGet the underlying numeric representation\nCompute the multiplicative inverse of an <code>FBig</code>\nDetermine if the Repr represents a finite number\nDetermine if the Repr represents the (±)infinity\nDetermine if the number can be regarded as an integer.\nDetermine if the Repr represents one\nDetermine if the Repr represents zero\nCalculate the natural logarithm function (<code>log(x)</code>) on the …\nCalculate the natural logarithm function (<code>log(x)</code>) on the …\nCalculate the natural logarithm function (<code>log(x+1)</code>) on the …\nCalculate the natural logarithm function (<code>log(x+1)</code>) on the …\nCreate a float operation context with the higher precision …\nMultiply two floating point numbers under this context.\nCreate a Repr instance representing the negative infinity\nCreate a Repr instance representing value negative one\nCreate a Repr from the significand and exponent. This …\nCreate a float operation context with the given precision …\nCreate a Repr instance representing value one\nRe-exported relevant operator traits from <code>dashu-base</code>\nRaise the floating point number to an floating point power.\nRaise the floating point number to an floating point power …\nRaise the floating point number to an integer power.\nRaise the floating point number to an integer power under …\nGet the maximum precision set for the float number.\nGet the precision limited from the context\nCalculate the remainder of <code>⌈lhs / rhs⌋</code>.\nGet a reference to the underlying numeric representation\nTraits and implementations for rounding during operations.\nReturns the integer nearest to self.\nGet the sign of the number. Zero value has a positive sign.\nGet the sign of the number\nGet the significand of the representation\nA number representing the sign of <code>self</code>.\nSplit the rational number into integral and fractional …\nCompute the square of this number (<code>self * self</code>)\nCalculate the square of the floating point number under …\nCalculate the square root of the floating point number.\nSubtract two floating point numbers under this context.\nConvert the float number to base 2 (with binary exponents) …\nConvert the float number to base 10 (with decimal …\nConvert the float number to f32 with the rounding mode …\nConvert the float number representation to a f32 with the …\nConvert the float number to f64 with HalfEven rounding …\nConvert the float number representation to a f64 with the …\nConvert the float number to integer with the given …\nConvert the float number representation to a IBig.\nGet the integral part of the float\nReturn the value of the least significant digit of the …\nExplicitly change the base of the float number.\nExplicitly change the base of the float number with given …\nExplicitly change the precision of the float number.\nExplicitly change the rounding mode of the number.\nCreate a Repr instance representing value zero\nAbsolute value.\nCompute the cubic root of the number.\nCompute Euclidean quotient.\nCompute Euclidean quotient and remainder at the same time.\nFast estimation of the binary logarithm of a number\nCompute Euclidean remainder.\nCompute the square root of the number.\nEstimate the bounds of the binary logarithm.\nEstimate the value of the binary logarithm. It’s …\nAdd one\nA trait providing the function to retrieve the error …\nThe result is exact, contains the result value\nThe result is inexact, contains the result value and error\nNo adjustment\nThe rounding operation that rounds to an opposite direction\nA trait describing the rounding strategy\nA type representing float operation result\nThe adjustment of a rounding operation\nSubtract one\nGiven a floating point number <code>f</code>, the output (L, R, incl_L, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBuilt-in rounding modes of the floating numbers.\nCalculate the rounding of the number (integer + fract / …\nCalculate the rounding of the number (integer + rem), …\nCalculate the rounding of the number (integer + numerator …\nRound away from 0\nRound toward -∞\nRound to the nearest value, ties away from zero\nRound to the nearest value, ties are rounded to an even …\nRound toward +∞\nRound toward 0 (default mode for binary float)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe primitive integer type that has exactly double the …\nAn signed arbitrary precision integer.\nIBig with value -1\nIBig with value 1\nUBig with value 1\nAn enum representing the sign of a number\nAn unsigned arbitrary precision integer.\nThe primitive integer type used to construct the big …\nIBig with value 0\nUBig with value 0\nRegard the number as a IBig number and return a reference …\nGet the raw representation in Words.\nGet the raw representation in Words.\nClear the <code>n</code>-th bit, <code>n</code> starts from 0.\nClear the high bits from <code>n+1</code>-th bit.\nCount the 1 bits in the integer\nCount the 0 bits in the integer after the leading bit 1.\nCompute the cubic of the number (<code>self * self * self</code>).\nCompute the cubic of the number (<code>self * self * self</code>).\nDefault value: 0.\nDefault value: 0.\nPrepared divisor types for fast division\nInteger formatting.\nReturns the argument unchanged.\nConvert boolean value to Sign, returns Negative for <code>true</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct from big-endian bytes.\nCreate a UBig from a DoubleWord.\nConstruct from little-endian bytes.\nCreate an IBig from the Sign and UBig magnitude\nCreate an IBig in a const context.\nConvert a string in a given base to IBig.\nConvert a string in a given base to UBig.\nConvert a string with an optional radix prefix to IBig, …\nConvert a string with an optional radix prefix to UBig, …\nConvert a string with an optional radix prefix to IBig, …\nConvert a string with an optional radix prefix to UBig, …\nCreate a UBig from a single Word.\nConvert a sequence of Words into a UBig\nCalculate the (truncated) logarithm of the magnitude of …\nCalculate the (truncated) logarithm of the UBig\nRepresentation in a given radix.\nRepresentation in a given radix.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the IBig into its Sign and UBig magnitude\nDetermine whether the integer is perfectly divisible by …\nDetermine whether the integer is perfectly divisible by …\nA const version of IBig::is_multiple_of, but only accepts …\nA const version of UBig::is_multiple_of, but only accepts …\nCheck whether the number is 1\nCheck whether the value is 1\nCheck whether the number is 0\nCheck whether the value is 0\nModular arithmetic.\nCalculate the nth-root of the integer rounding towards zero\nCalculate the nth-root of the integer rounding towards zero\nRe-exported relevant operator traits from <code>dashu-base</code>\nRaises self to the power of <code>exp</code>.\nRaises self to the power of <code>exp</code>.\nDivide out all multiples of the factor from the integer, …\nSet the <code>n</code>-th bit, n starts from 0.\nGet the sign of the number. Zero value has a positive sign.\nA number representing the sign of <code>self</code>.\nSplit this integer into low bits and high bits.\nCompute the square of the number (<code>self * self</code>).\nCalculate the square of the number (<code>x * x</code>).\nReturn big-endian bytes.\nConvert to f32.\nConvert to f32.\nConvert to f64.\nConvert to f64.\nReturn little-endian bytes.\nReturns the number of trailing ones in the two’s …\nReturns the number of trailing ones in the binary …\nReturns the number of trailing zeros in the two’s …\nReturns the number of trailing zeros in the binary …\nAn UBig with some pre-computed fields to support faster …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate an element of the modulo ring from another type.\nRepresentation of a UBig or IBig in any radix between …\nMaximum supported radix.\nMinimum supported radix.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrait for types that can be converted into an …\nModular arithmetic.\nCalculate 2*target mod m in reduced form\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMultiplicative inverse.\nGet the modulus of the ring that this element belongs to.\nExponentiation.\nGet the residue in range <code>0..n</code> in an n-element ring.\nCalculate target^2 mod m in reduced form\nAbsolute value.\nBit query for integers\nCompute the cubic root of the number.\nComputer the floored cubic root of the number and return …\nCompute Euclidean quotient.\nCompute quotient and remainder at the same time.\nCompute quotient inplace and return remainder at the same …\nCompute Euclidean quotient and remainder at the same time.\nFast estimation of the binary logarithm of a number\nCompute the greatest common divisor between self and the …\nCompute the greatest common divisor.\nFunctions related to the power of two.\nCompute Euclidean remainder.\nCompute the square root of the number.\nComputer the floored square root of the number and return …\nUnsigned absolute value.\nReturns true if the <code>n</code>-th bit is set in its two’s …\nEffective bit length of the binary representation.\nCompute the greatest common divisor between the two …\nCalculate the greatest common divisor between the two …\nTest if self is a power of two (<code>2^k</code>)\nEstimate the bounds of the binary logarithm.\nEstimate the value of the binary logarithm. It’s …\nGet the smallest power of two greater than or equal to …\nRBig with value -1\nRelaxed with value -1\nRBig with value 1\nRelaxed with value 1\nAn arbitrary precision rational number.\nAn arbitrary precision rational number without strict …\nThe primitive integer type used to construct the big …\nRBig with value 0\nRelaxed with value 0\nRegard the number as a Relaxed number and return a …\nConvert this rational number into an RBig version\nCompute the least integer that is greater than or equal to …\nCompute the smallest integer that is greater than this …\nCompute the cubic of the number (<code>self * self * self</code>).\nCompute the cubic of the number (<code>self * self * self</code>).\nGet the denominator of the rational number\nGet the denominator of the rational number\nCompute the greatest integer that is less than or equal to …\nCompute the largest integer that is less than or equal to …\nReturns the fractional part of the rational number\nReturns the fractional part of the rational number\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a rational number from a signed numerator and an …\nCreate a rational number from a signed numerator and a …\nCreate a rational number in a const context\nCreate a rational number in a const context\nCreate a rational number from a signed numerator and a …\nCreate a rational number from a signed numerator and a …\nConvert a string in a given base to RBig.\nConvert a string in a given base to Relaxed.\nConvert a string with optional radix prefixes to RBig, …\nConvert a string with optional radix prefixes to RBig, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert the rational number into (numerator, denumerator) …\nConvert the rational number into (numerator, denumerator) …\nDetermine if the number can be regarded as an integer.\nCheck whether the number is 1\nCheck whether the number is 1\nDetermine if this rational number is simpler than the …\nCheck whether the number is 0\nCheck whether the number is 0\nFind the closest rational number to this number with a …\nFind the closest rational number that is less than this …\nFind the closest rational number that is greater than this …\nGet the numerator of the rational number\nGet the numerator of the rational number\nRe-exported relevant operator traits from <code>dashu-base</code>\nRaise this number to a power of <code>n</code>.\nRaise this number to a power of <code>n</code>.\nConvert this rational number into a Relaxed version\nCompute the integer that closest to this number.\nCompute the integer that closest to this number.\nGet the sign of the number. Zero value has a positive sign.\nGet the sign of the number. Zero value has a positive sign.\nA number representing the sign of <code>self</code>.\nA number representing the sign of <code>self</code>.\nFind the simplest rational number in the rounding interval …\nFind the simplest rational number in the rounding interval …\nExamples\nFind the simplest rational number in the open interval …\nSplit the rational number into integral and fractional …\nSplit the rational number into integral and fractional …\nCompute the square of the number (<code>self * self</code>).\nCompute the square of the number (<code>self * self</code>).\nConvert the rational number to a f32 with guaranteed …\nConvert the rational number to a f32 with guaranteed …\nConvert the rational number to a f32.\nConvert the rational number to a f32.\nConvert the rational number to a f64 with guaranteed …\nConvert the rational number to a f64 with guaranteed …\nConvert the rational number to a f64.\nConvert the rational number to a f64.\nConvert the rational number to a FBig with guaranteed …\nConvert the rational number to a FBig with guaranteed …\nConvert the rational number to an IBig.\nConvert the rational number to am IBig.\nReturns the integral part of the rational number.\nReturns the integral part of the rational number.\nAbsolute value.\nCompute Euclidean quotient.\nCompute Euclidean quotient and remainder at the same time.\nFast estimation of the binary logarithm of a number\nCompute Euclidean remainder.\nEstimate the bounds of the binary logarithm.\nEstimate the value of the binary logarithm. It’s …")