searchState.loadedDescShard("crrl", 0, "Crrl is a Rust library for cryptographic research.\nCodes at or above this point can be used by users to …\nThe <code>rand_core</code> types are re-exported so that users of crrl …\nCodes below this point represent OS Errors (i.e. positive …\nThe <code>rand_core</code> types are re-exported so that users of crrl …\nThe <code>rand_core</code> types are re-exported so that users of crrl …\nArchitecture-specific implementations of finite fields.\nRetrieve the error code, if any.\nDecaf448 implementation.\nEdwards25519 curve implementation.\nEdwards448 curve implementation.\nFinite fields.\nFill <code>dest</code> with random data.\nReturns the argument unchanged.\nFROST implementation.\nGLS254 implementation.\nReference the inner error (<code>std</code> only)\nCalls <code>U::from(self)</code>.\nJq255e implementation.\nJq255s implementation.\nLMS implementation.\nConstruct from any type supporting <code>std::error::Error</code>\nReturn the next random <code>u32</code>.\nReturn the next random <code>u64</code>.\nNIST P-256 curve implementation.\nExtract the raw OS error code (if this error came from the …\nRistreto255 implementation.\nsecp256k1 curve implementation.\nUnwrap the inner error (<code>std</code> only)\nFill <code>dest</code> entirely with random data.\nX25519 key-exchange algorithm.\nX448 key-exchange algorithm.\nFinite field: integers modulo 2^255 - <code>MQ</code>.\nFinite field: integers modulo 2^255 - 19.\nFinite field: integers modulo 2^255 - 18651.\nFinite field: integers modulo 2^255 - 3957.\nFinite field: integers modulo 2^448 - 2^224 - 1.\nFinite fields: GF(2^127) and GF(2^254)\nFinite fields: GF(2^127) and GF(2^254)\nFinite field: integers modulo 2^256 - 2^224 + 2^192 + 2^96 …\nFinite field: integers modulo 2^256 - 2^32 - 977.\nFinite field: generic 256-bit modulus.\nA type similar to <code>ModInt256</code> but with “enforced …\nFixed-size integers with constant-time operations: …\nFixed-size integers with constant-time operations: …\nFixed-size integers with constant-time operations: …\nFinite field generic implementation: support macro.\nFinite field generic implementation: support macro (tests).\nA custom 128-bit integer with some constant-time …\nA custom 256-bit integer with some constant-time …\nA custom 384-bit integer with some constant-time …\nInterpreting this value as a signed 128-bit integer, …\nReturn <code>floor((self + b)/2^224) mod 2^32</code> (i.e. addition …\nReturn the borrow resulting from the subtraction of <code>b</code> from …\nInterpreting this value as a signed 128-bit integer <code>x</code>, …\nEncodes a scalar element into bytes (little-endian).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>self mod 2^n</code> and <code>(floor(self/2^n) + cc) mod 2^128</code>. …\nSpecial container for “not reduced” values returned by …\nReturn self + b and self + b - c (no reduction).\nReturn self + rhs (no reduction).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstant-time table lookup: given a table of 48 field …\nConstant-time table lookup: given a table of 64 field …\nReturn 2*self (no reduction).\nReturn 2<em>self + b and 2</em>self - b (no reduction).\nReturn self - rhs (no reduction).\nReturn self - b and self - b + 2*c (no reduction).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nElement of GF(2^127), using modulus 1 + z^63 + z^127.\nElement of GF(2^254), defined over GF(2^127)[u] with …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInvert this value; if this value is zero, then zero is …\nConstant-time table lookup, short table. This is similar to\nInvert this value; if this value is zero, then it stays at …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe square root of -1 that corresponds to the zeta() …\nEncodes a scalar element into bytes (little-endian).\nEncodes a scalar element into bytes (little-endian).\nEncodes a scalar element into bytes (little-endian).\nEncodes a scalar element into bytes (little-endian).\nEncodes a scalar element into bytes (little-endian).\nEncodes a scalar element into bytes (little-endian).\nEncodes a scalar element into bytes (little-endian).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBLAKE2s context (unkeyed).\nConvenience wrapper for BLAKE2s (unkeyed) with a 256-bit …\nBLAKE2s context (with a key). The key is saved internally, …\nFinalize the current computation and get a 32-byte output. …\nFinalize the current computation and get a 32-byte output. …\nFinalize this context and get the output. The output (…\nFinalize this context and get the output. The output (…\nFinalize this context and get the output. The output (32 …\nFinalize this context and get the output. The output (…\nFinalize this context and get the output. The output (…\nFinalize this context and get the output. The output (32 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nOne-stop function for hashing some input into a 32-byte …\nOne-stop function for hashing some input into an output …\nOne-stop function for hashing some input (and a key) into …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitialize the context. The output length (in bytes) MUST …\nInitialize the context. The output length (in bytes) must …\nInitialize a new context.\nReset this context.\nReset this context.\nInject some more bytes into the context.\nInject some more bytes into the context.\nInject some more bytes into the context.\nThe conventional base point in the group.\nThe neutral element (identity point) in the group.\nA decaf448 point.\nA decaf448 scalar (integer modulo the group prime order <code>L</code>).\nDecodes an element from its binary representation.\nDoubles this element.\nEncodes this element into bytes.\nCompares two points for equality.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTests whether this element is the neutral (identity point).\nGiven scalars <code>u</code> and <code>v</code>, returns <code>u*self + v*B</code> (with <code>B</code> being …\nReturns the product of the conventional base (<code>Self::BASE</code>) …\nThe one-way map of bytes to decaf448 elements.\nReturns an element equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or to …\nConditionally copies the provided element (<code>P</code>) into <code>self</code>.\nConditionally negates this point.\nSets this element by decoding its binary representation.\nDoubles this element (in place).\nSets this element to n times the conventional base (…\nNegates this element.\nDoubles this element n times (in place).\nCheck whether <code>s*B = R + k*A</code>, for the provided scalars <code>s</code> …\nDoubles this element n times.\nThe conventional base point in the curve.\nThe group neutral (identity point) in the curve.\nA point on the twisted Edwards curve edwards25519.\nAn Ed25519 private key.\nAn Ed25519 public key.\nIntegers modulo L = 2^252 + …\nTries to decode a point from some bytes.\nDecodes a private key from bytes.\nDoubles this point.\nEncodes a scalar element into bytes (little-endian).\nEncodes this point into exactly 32 bytes.\nEncodes a private key into 32 bytes.\nEncodes the key into exactly 32 bytes.\nCompares two points for equality.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an instance from a curve point.\nInstantiates a private key from the provided seed.\nGenerates a new private key from a cryptographically …\nTests whether this point is a low-order point, i.e. a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests whether this point is in the proper subgroup of …\nTests whether this point is the neutral (identity point on …\nCreates a point by multiplying the conventional generator …\nReturns a point equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or <code>P1</code> (if\nConditionally copies the provided point (<code>P</code>) into <code>self</code>.\nConditionally negates this point.\nTries to decode a point from bytes.\nDoubles this point (in place).\nMultiplies this point by a scalar (in place).\nGiven scalars <code>u</code> and <code>v</code>, sets this point to <code>u*self + v*B</code> …\nMultiplies this point by a small integer.\nSets this point by multiplying the conventional generator …\nNegates this point (in place).\nDoubles this point n times (in place).\nSigns a message with a context.\nSigns a pre-hashed message.\nSigns a message.\nMaps this point to the corresponding Montgomery curve and …\nMaps this point to the corresponding Montgomery curve and …\nVerifies a signature on a message.\nCheck whether <code>8*s*B = 8*R + 8*k*A</code>, for the provided …\nVerifies a signature on a hashed message.\nVerifies a signature on a message.\nVerifies a truncated signature on a message.\nVerifies a truncated signature on a message.\nVerifies a truncated signature on a message.\nDoubles this point n times.\nThe conventional base point in the curve.\nThe group neutral (identity point) in the curve.\nA point on the Edwards curve edwards448.\nAn Ed448 private key.\nAn Ed448 public key.\nTries to decode a point from some bytes.\nDecodes a private key from bytes.\nDoubles this point.\nEncodes this point into exactly 57 bytes.\nEncodes a private key into 57 bytes.\nEncodes the key into exactly 57 bytes.\nCompares two points for equality.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an instance from a curve point.\nInstantiates a private key from the provided seed.\nGenerates a new private key from a cryptographically …\nCompute the half of this value.\nTests whether this point is a low-order point, i.e. a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests whether this point is in the proper subgroup of …\nTests whether this point is the neutral (identity point on …\nLegendre symbol on this value. Return value is: 0   if …\nCreates a point by multiplying the conventional generator …\nReturns a point equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or <code>P1</code> (if\nConditionally copies the provided point (<code>P</code>) into <code>self</code>.\nConditionally negates this point.\nTries to decode a point from bytes.\nDoubles this point (in place).\nHalve this value.\nMultiplies this point by a scalar (in place).\nGiven scalars <code>u</code> and <code>v</code>, sets this point to <code>u*self + v*B</code> …\nMultiplies this point by a small integer.\nMultiply this value by a small integer k.\nSets this point by multiplying the conventional generator …\nNegates this point (in place).\nDoubles this point n times (in place).\nCompute the square of this value.\nSigns a message (with context).\nSigns a pre-hashed message.\nSigns a message.\nCompute the square of this value.\nMaps this point to the corresponding Montgomery curve and …\nVerifies a signature on a message (with context).\nCheck whether <code>4*s*B = 4*R + 4*k*A</code>, for the provided …\nVerifies a signature on a hashed message.\nVerifies a signature on a message.\nDoubles this point n times.\nCompute the square of this value.\nFROST(Ed25519, SHA-512)\nFROST(Ed448, SHAKE256)\nFROST(P-256, SHA-256)\nFROST(ristretto255, SHA-512)\nFROST(secp256k1, SHA-256)\nA signer’s commitment.\nA coordinator’s permanent state.\nEncoded private key length (in bytes).\nEncoded public key length (in bytes).\nPrivate key share encoded length (in bytes).\nSigner’s public key encoded length (in bytes).\nEncoded nonce length (in bytes).\nEncoded length (in bytes).\nEncoded length (in bytes) of a signature share.\nEncoded length (in bytes) of a signature.\nA group private key.\nA group public key.\nA tagging structure for functions related to key …\nFROST specification, in appendix D, mandates that the key …\nA signer’s nonce.\nA FROST signature.\nA signature share.\nA private key share.\nA signer’s public key.\nA VSS element.\nVerifies signature shares received from the signers, and …\nChoose the signers from a list of commitments.\nGenerates nonces and commitments for a new signature …\nDecodes this private key from bytes.\nDecodes this public key from bytes.\nDecodes this share from bytes.\nDecodes this public key from bytes.\nDecodes this nonce from bytes.\nDecodes this commitment from bytes.\nDecode a signature share from bytes.\nDecode a signature from bytes.\nDecodes a VSS commitment (list of VSS elements) from bytes.\nDecodes a commitment list from bytes.\nDerives the group information (individual signer public …\nEncodes this private key into bytes.\nEncodes this public key into bytes.\nEncodes this private key share into bytes.\nEncodes this public key into bytes.\nEncodes this nonce into bytes.\nEncodes this commitment into bytes.\nEncode a signature share into bytes.\nEncode a signature into bytes.\nEncodes a VSS commitment (list of VSS elements) into bytes.\nEncodes a commitment list into bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a new (group) private key.\n(Re)computes the commitment corresponding to this nonce.\nGets the public key corresponding to this private key.\nGet the public key for this signer.\nSigner identifier\nSigner identifier\nSigner identifier\nSigner identifier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an instance over the provided group public key and …\nGenerates a signature (single-signer version).\nComputes a signature share.\nGenerates a signature (single-signer version, seeded).\nSplit a group private key into shares.\nVerifies a FROST signature.\nVerifies a FROST signature.\nVerifies a signature share relatively to this signer’s …\nVerifies that this share was properly computed, given the …\nA signer’s commitment.\nA coordinator’s permanent state.\nEncoded private key length (in bytes).\nEncoded public key length (in bytes).\nPrivate key share encoded length (in bytes).\nSigner’s public key encoded length (in bytes).\nEncoded nonce length (in bytes).\nEncoded length (in bytes).\nEncoded length (in bytes) of a signature share.\nEncoded length (in bytes) of a signature.\nA group private key.\nA group public key.\nA tagging structure for functions related to key …\nFROST specification, in appendix D, mandates that the key …\nA signer’s nonce.\nA FROST signature.\nA signature share.\nA private key share.\nA signer’s public key.\nA VSS element.\nVerifies signature shares received from the signers, and …\nChoose the signers from a list of commitments.\nGenerates nonces and commitments for a new signature …\nDecodes this private key from bytes.\nDecodes this public key from bytes.\nDecodes this share from bytes.\nDecodes this public key from bytes.\nDecodes this nonce from bytes.\nDecodes this commitment from bytes.\nDecode a signature share from bytes.\nDecode a signature from bytes.\nDecodes a VSS commitment (list of VSS elements) from bytes.\nDecodes a commitment list from bytes.\nDerives the group information (individual signer public …\nEncodes this private key into bytes.\nEncodes this public key into bytes.\nEncodes this private key share into bytes.\nEncodes this public key into bytes.\nEncodes this nonce into bytes.\nEncodes this commitment into bytes.\nEncode a signature share into bytes.\nEncode a signature into bytes.\nEncodes a VSS commitment (list of VSS elements) into bytes.\nEncodes a commitment list into bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a new (group) private key.\n(Re)computes the commitment corresponding to this nonce.\nGets the public key corresponding to this private key.\nGet the public key for this signer.\nSigner identifier\nSigner identifier\nSigner identifier\nSigner identifier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an instance over the provided group public key and …\nGenerates a signature (single-signer version).\nComputes a signature share.\nGenerates a signature (single-signer version, seeded).\nSplit a group private key into shares.\nVerifies a FROST signature.\nVerifies a FROST signature.\nVerifies a signature share relatively to this signer’s …\nVerifies that this share was properly computed, given the …\nA signer’s commitment.\nA coordinator’s permanent state.\nEncoded private key length (in bytes).\nEncoded public key length (in bytes).\nPrivate key share encoded length (in bytes).\nSigner’s public key encoded length (in bytes).\nEncoded nonce length (in bytes).\nEncoded length (in bytes).\nEncoded length (in bytes) of a signature share.\nEncoded length (in bytes) of a signature.\nA group private key.\nA group public key.\nA tagging structure for functions related to key …\nFROST specification, in appendix D, mandates that the key …\nA signer’s nonce.\nA FROST signature.\nA signature share.\nA private key share.\nA signer’s public key.\nA VSS element.\nVerifies signature shares received from the signers, and …\nChoose the signers from a list of commitments.\nGenerates nonces and commitments for a new signature …\nDecodes this private key from bytes.\nDecodes this public key from bytes.\nDecodes this share from bytes.\nDecodes this public key from bytes.\nDecodes this nonce from bytes.\nDecodes this commitment from bytes.\nDecode a signature share from bytes.\nDecode a signature from bytes.\nDecodes a VSS commitment (list of VSS elements) from bytes.\nDecodes a commitment list from bytes.\nDerives the group information (individual signer public …\nEncodes this private key into bytes.\nEncodes this public key into bytes.\nEncodes this private key share into bytes.\nEncodes this public key into bytes.\nEncodes this nonce into bytes.\nEncodes this commitment into bytes.\nEncode a signature share into bytes.\nEncode a signature into bytes.\nEncodes a VSS commitment (list of VSS elements) into bytes.\nEncodes a commitment list into bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a new (group) private key.\n(Re)computes the commitment corresponding to this nonce.\nGets the public key corresponding to this private key.\nGet the public key for this signer.\nSigner identifier\nSigner identifier\nSigner identifier\nSigner identifier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an instance over the provided group public key and …\nGenerates a signature (single-signer version).\nComputes a signature share.\nGenerates a signature (single-signer version, seeded).\nSplit a group private key into shares.\nVerifies a FROST signature.\nVerifies a FROST signature.\nVerifies a signature share relatively to this signer’s …\nVerifies that this share was properly computed, given the …\nA signer’s commitment.\nA coordinator’s permanent state.\nEncoded private key length (in bytes).\nEncoded public key length (in bytes).\nPrivate key share encoded length (in bytes).\nSigner’s public key encoded length (in bytes).\nEncoded nonce length (in bytes).\nEncoded length (in bytes).\nEncoded length (in bytes) of a signature share.\nEncoded length (in bytes) of a signature.\nA group private key.\nA group public key.\nA tagging structure for functions related to key …\nFROST specification, in appendix D, mandates that the key …\nA signer’s nonce.\nA FROST signature.\nA signature share.\nA private key share.\nA signer’s public key.\nA VSS element.\nVerifies signature shares received from the signers, and …\nChoose the signers from a list of commitments.\nGenerates nonces and commitments for a new signature …\nDecodes this private key from bytes.\nDecodes this public key from bytes.\nDecodes this share from bytes.\nDecodes this public key from bytes.\nDecodes this nonce from bytes.\nDecodes this commitment from bytes.\nDecode a signature share from bytes.\nDecode a signature from bytes.\nDecodes a VSS commitment (list of VSS elements) from bytes.\nDecodes a commitment list from bytes.\nDerives the group information (individual signer public …\nEncodes this private key into bytes.\nEncodes this public key into bytes.\nEncodes this private key share into bytes.\nEncodes this public key into bytes.\nEncodes this nonce into bytes.\nEncodes this commitment into bytes.\nEncode a signature share into bytes.\nEncode a signature into bytes.\nEncodes a VSS commitment (list of VSS elements) into bytes.\nEncodes a commitment list into bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a new (group) private key.\n(Re)computes the commitment corresponding to this nonce.\nGets the public key corresponding to this private key.\nGet the public key for this signer.\nSigner identifier\nSigner identifier\nSigner identifier\nSigner identifier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an instance over the provided group public key and …\nGenerates a signature (single-signer version).\nComputes a signature share.\nGenerates a signature (single-signer version, seeded).\nSplit a group private key into shares.\nVerifies a FROST signature.\nVerifies a FROST signature.\nVerifies a signature share relatively to this signer’s …\nVerifies that this share was properly computed, given the …\nA signer’s commitment.\nA coordinator’s permanent state.\nEncoded private key length (in bytes).\nEncoded public key length (in bytes).\nPrivate key share encoded length (in bytes).\nSigner’s public key encoded length (in bytes).\nEncoded nonce length (in bytes).\nEncoded length (in bytes).\nEncoded length (in bytes) of a signature share.\nEncoded length (in bytes) of a signature.\nA group private key.\nA group public key.\nA tagging structure for functions related to key …\nFROST specification, in appendix D, mandates that the key …\nA signer’s nonce.\nA FROST signature.\nA signature share.\nA private key share.\nA signer’s public key.\nA VSS element.\nVerifies signature shares received from the signers, and …\nChoose the signers from a list of commitments.\nGenerates nonces and commitments for a new signature …\nDecodes this private key from bytes.\nDecodes this public key from bytes.\nDecodes this share from bytes.\nDecodes this public key from bytes.\nDecodes this nonce from bytes.\nDecodes this commitment from bytes.\nDecode a signature share from bytes.\nDecode a signature from bytes.\nDecodes a VSS commitment (list of VSS elements) from bytes.\nDecodes a commitment list from bytes.\nDerives the group information (individual signer public …\nEncodes this private key into bytes.\nEncodes this public key into bytes.\nEncodes this private key share into bytes.\nEncodes this public key into bytes.\nEncodes this nonce into bytes.\nEncodes this commitment into bytes.\nEncode a signature share into bytes.\nEncode a signature into bytes.\nEncodes a VSS commitment (list of VSS elements) into bytes.\nEncodes a commitment list into bytes.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates a new (group) private key.\n(Re)computes the commitment corresponding to this nonce.\nGets the public key corresponding to this private key.\nGet the public key for this signer.\nSigner identifier\nSigner identifier\nSigner identifier\nSigner identifier\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an instance over the provided group public key and …\nGenerates a signature (single-signer version).\nComputes a signature share.\nGenerates a signature (single-signer version, seeded).\nSplit a group private key into shares.\nVerifies a FROST signature.\nVerifies a FROST signature.\nVerifies a signature share relatively to this signer’s …\nVerifies that this share was properly computed, given the …\nThe conventional base point (group generator).\nECDH key exchange.\nThe square root of -1 that corresponds to the zeta() …\nThe group neutral element.\nAn element of the GLS254 group.\nA GLS254 private key.\nA GLS254 public key.\nIntegers modulo r = 2^253 + …\nTries to decode a point from some bytes.\nInstantiates a private key by decoding it from bytes.\nDecodes the provided bytes as a public key.\nEncodes a scalar element into bytes (little-endian).\nEncodes this point into exactly 32 bytes.\nEncode a private key into bytes.\nEncode this public key into exactly 32 bytes.\nCompares two points for equality.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates and instance from a curve point.\nInstantiates a private key from a secret scalar.\nGenerates a new private key from a cryptographically …\nHashes some data into a point.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests whether this point is the neutral (identity point on …\nGiven integer <code>u0</code> and <code>u1</code>, and scalar <code>v</code>, returns …\nGiven scalars <code>u</code> and <code>v</code>, returns <code>u*self + v*B</code> (with <code>B</code> being …\nCreates a point by multiplying the conventional generator …\nReturns a point equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or <code>P1</code> (if\nConditionally copies the provided point (<code>P</code>) into <code>self</code>.\nConditionally negates this point.\nTries to decode a point from bytes.\nDoubles this point (in place).\nMultiplies this point by a scalar (in place).\nGiven integer <code>u0</code> and <code>u1</code>, and scalar <code>v</code>, sets this point to …\nGiven scalars <code>u</code> and <code>v</code>, sets this point to <code>u*self + v*B</code> …\nMultiplies this point by a small integer.\nSets this point by multiplying the conventional generator …\nNegates this point (in place).\nDoubles this point n times (in place).\nApplies the GLS endomorphism on this point. This …\nSigns a message with this private key.\nSigns a message with this private key.\nSigns a message with this private key.\nSplits a scalar k into k0 and k1 (signed) such that k = k0 …\nSplits a scalar k into <em>odd</em> k0 and k1 (signed) such that k …\nVerifies a signature on a message against this public key.\nApplies the GLS endomorphism on this point. This …\nThe conventional base point (group generator).\nECDH key exchange.\nThe group neutral element.\nAn element in the jq255e group.\nA jq255e private key.\nA jq255e public key.\nIntegers modulo r = 2^254 - …\nTries to decode a point from some bytes.\nInstantiates a private key by decoding it from bytes.\nDecodes the provided bytes as a public key.\nDoubles this point.\nEncodes a scalar element into bytes (little-endian).\nEncodes this point into exactly 32 bytes.\nEncode a private key into bytes.\nEncode this public key into exactly 32 bytes.\nCompares two points for equality.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates and instance from a curve point.\nInstantiates a private key from a secret scalar.\nGenerates a new private key from a cryptographically …\nHashes some data into a point.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests whether this point is the neutral (identity point on …\nGiven integer <code>u</code> and scalar <code>v</code>, returns <code>u*self + v*B</code> (with <code>B</code> …\nGiven scalars <code>u</code> and <code>v</code>, returns <code>u*self + v*B</code> (with <code>B</code> being …\nCreates a point by multiplying the conventional generator …\nReturns a point equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or <code>P1</code> (if\nConditionally copies the provided point (<code>P</code>) into <code>self</code>.\nConditionally negates this point.\nTries to decode a point from bytes.\nDoubles this point (in place).\nMultiplies this point by a scalar (in place).\nGiven integer <code>u</code> and scalar <code>v</code>, sets this point to …\nGiven scalars <code>u</code> and <code>v</code>, sets this point to <code>u*self + v*B</code> …\nMultiplies this point by a small integer.\nSets this point by multiplying the conventional generator …\nNegates this point (in place).\nDoubles this point n times (in place).\nSigns a message with this private key.\nSigns a message with this private key.\nSigns a message with this private key.\nVerifies a signature on a message against this public key.\nDoubles this point n times.\nThe conventional base point (group generator).\nECDH key exchange.\nThe group neutral element.\nAn element in the jq255s group.\nA jq255s private key.\nA jq255s public key.\nIntegers modulo r = 2^254 + …\nTries to decode a point from some bytes.\nInstantiates a private key by decoding it from bytes.\nDecodes the provided bytes as a public key.\nDoubles this point.\nEncodes a scalar element into bytes (little-endian).\nEncodes this point into exactly 32 bytes.\nEncode a private key into bytes.\nEncode this public key into exactly 32 bytes.\nCompares two points for equality.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates and instance from a curve point.\nInstantiates a private key from a secret scalar.\nGenerates a new private key from a cryptographically …\nHashes some data into a point.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests whether this point is the neutral (identity point on …\nGiven integer <code>u</code> and scalar <code>v</code>, returns <code>u*self + v*B</code> (with <code>B</code> …\nGiven scalars <code>u</code> and <code>v</code>, returns <code>u*self + v*B</code> (with <code>B</code> being …\nCreates a point by multiplying the conventional generator …\nReturns a point equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or <code>P1</code> (if\nConditionally copies the provided point (<code>P</code>) into <code>self</code>.\nConditionally negates this point.\nTries to decode a point from bytes.\nDoubles this point (in place).\nMultiplies this point by a scalar (in place).\nGiven integer <code>u</code> and scalar <code>v</code>, sets this point to …\nGiven scalars <code>u</code> and <code>v</code>, sets this point to <code>u*self + v*B</code> …\nMultiplies this point by a small integer.\nSets this point by multiplying the conventional generator …\nNegates this point (in place).\nDoubles this point n times (in place).\nSigns a message with this private key.\nSigns a message with this private key.\nSigns a message with this private key.\nVerifies a signature on a message against this public key.\nDoubles this point n times.\nLMS_SHA256_M24_H5 with LMOTS_SHA256_N24_W8\nLMS_SHA256_M32_H5 with LMOTS_SHA256_N32_W8\nLMS_SHAKE_M24_H5 with LMOTS_SHAKE_N24_W8\nLMS_SHAKE_M32_H5 with LMOTS_SHAKE_N32_W8\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe conventional base point in the curve.\nThe neutral element (point-at-infinity) in the curve.\nA point on the short Weierstraß curve P-256.\nA P-256 private key simply wraps around a scalar.\nA P-256 public key simply wraps around a curve point.\nIntegers modulo the curve order n (a 256-bit prime).\nTries to decode a point.\nInstantiates a private key by decoding the provided 32-byte\nDecodes a public key from bytes.\nDoubles this point.\nEncodes a scalar element into bytes (little-endian).\nEncodes this private key into exactly 32 bytes.\nEncodes this point in compressed format (33 bytes).\nEncodes this public key into the compressed format (33 …\nEncodes this point in uncompressed format (65 bytes).\nEncodes this public key into the compressed format (65 …\nCompares two points for equality.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an instance from the provided affine coordinates.\nCreates an instance from the provided projective …\nInstantiates a private key from a random seed.\nGenerates a new private key from a cryptographically …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests whether this point is the neutral …\nGiven scalars <code>u</code> and <code>v</code>, returns point <code>u*self + v*G</code> (with <code>G</code> …\nCreates a point by multiplying the conventional generator …\nPrepares a signature value for truncation.\nReturns a point equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or <code>P1</code> (if\nSets this instance from the provided affine coordinates.\nConditionally negates this point.\nTries to decode a point.\nDoubles this point (in place).\nMultiplies this point by a scalar (in place).\nGiven scalars <code>u</code> and <code>v</code>, sets this point to <code>u*self + v*G</code> …\nMultiplies this point by a small integer.\nSets this point by multiplying the conventional generator …\nNegates this point (in place).\nSets this instance from the provided projective …\nDoubles this point n times (in place).\nSigns a hash value with ECDSA.\nGets the affine (x, y) coordinates for this point.\nGets the projective coordinates (X:Y:Z) for this point.\nGets the public key corresponding to that private key.\nFrom points P0 and P1, returns the affine x coordinates of …\nVerifies a signature on a given hashed message.\nCheck whether <code>s*G = R + k*Q</code>, for the provided scalars <code>s</code> …\nVerifies a truncated signature on a given hashed message.\nGiven the x coordinates of points P0, P1 and Q (with Q = …\nDoubles this point n times.\nThe conventional base point in the group.\nThe neutral element (identity point) in the group.\nA ristretto255 point.\nA ristretto255 scalar (integer modulo the group prime …\nDecodes an element from its binary representation.\nDoubles this element.\nEncodes this element into bytes.\nCompares two points for equality.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTests whether this element is the neutral (identity point).\nGiven scalars <code>u</code> and <code>v</code>, returns <code>u*self + v*B</code> (with <code>B</code> being …\nReturns the product of the conventional base (<code>Self::BASE</code>) …\nThe one-way map of bytes to ristretto255 elements.\nReturns an element equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or to …\nConditionally copies the provided element (<code>P</code>) into <code>self</code>.\nConditionally negates this point.\nSets this element by decoding its binary representation.\nDoubles this element (in place).\nSets this element to n times the conventional base (…\nNegates this element.\nDoubles this element n times (in place).\nCheck whether <code>s*B = R + k*A</code>, for the provided scalars <code>s</code> …\nDoubles this element n times.\nThe conventional base point in the curve.\nThe neutral element (point-at-infinity) in the curve.\nA point on the short Weierstraß curve secp256k1.\nA secp256k1 private key simply wraps around a scalar.\nA secp256k1 public key simply wraps around a curve point.\nIntegers modulo the curve order n (a 256-bit prime).\nTries to decode a point.\nInstantiates a private key by decoding the provided 32-byte\nDecodes a public key from bytes.\nDoubles this point.\nEncodes a scalar element into bytes (little-endian).\nEncodes this private key into exactly 32 bytes.\nEncodes this point in compressed format (33 bytes).\nEncodes this public key into the compressed format (33 …\nEncodes this point in uncompressed format (65 bytes).\nEncodes this public key into the compressed format (65 …\nCompares two points for equality.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates an instance from the provided affine coordinates.\nCreates an instance from the provided projective …\nInstantiates a private key from a random seed.\nGenerates a new private key from a cryptographically …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTests whether this point is the neutral …\nGiven scalars <code>u</code> and <code>v</code>, returns point <code>u*self + v*G</code> (with <code>G</code> …\nCreates a point by multiplying the conventional generator …\nReturns a point equal to <code>P0</code> (if <code>ctl</code> = 0x00000000) or <code>P1</code> (if\nSets this instance from the provided affine coordinates.\nConditionally negates this point.\nTries to decode a point.\nDoubles this point (in place).\nMultiplies this point by a scalar (in place).\nGiven scalars <code>u</code> and <code>v</code>, sets this point to <code>u*self + v*G</code> …\nMultiplies this point by a small integer.\nSets this point by multiplying the conventional generator …\nNegates this point (in place).\nSets this instance from the provided projective …\nDoubles this point n times (in place).\nSigns a hash value with ECDSA.\nGets the affine (x, y) coordinates for this point.\nGets the projective coordinates (X:Y:Z) for this point.\nGets the public key corresponding to that private key.\nVerifies a signature on a given hashed message.\nCheck whether <code>s*G = R + k*Q</code>, for the provided scalars <code>s</code> …\nDoubles this point n times.\nX25519 function (from RFC 7748), general case.\nSpecialized version of X25519, when applied to the …\nX448 function (from RFC 7748), general case.\nSpecialized version of X448, when applied to the …")